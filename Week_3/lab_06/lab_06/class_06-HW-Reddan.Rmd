---
title: 'HW Class 6: Write a Function'
author: "Jack Reddan"
date: "10/17/2021"
output: github_document
#output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Section 1: Improving analysis code by writing functions

## A  
Improve the below code:  
```{r, results='hide'}
df <- data.frame(a=1:10, b=seq(200, 400, length = 10), c=11:20, d=NA)

df$a <- (df$a - min(df$a)) / (max(df$a) - min(df$a))

df$b <- (df$b - min(df$b)) / (max(df$b) - min(df$b))

df$c <- (df$c - min(df$c)) / (max(df$c) - min(df$c))

df$d <- (df$d - min(df$d)) / (max(df$d) - min(df$d))
```

A function can be written to apply over the data frame.  
```{r}
# Argument 'x' should be a numeric vector where all values are not equal
# (e.g. length(unique(x)) != 1)
norm_diff_to_min <- function(x){
  
  # Rewrite 'x' as the difference of each component to the minimum value, and
  # normalize to the maximum difference
  x <- (x - min(x)) / (max(x) - min(x))
  
  # Return the new vector 'x'
  return(x)
}

df2 <- as.data.frame(apply(df, 2, norm_diff_to_min))
```

The two data frames, df ad df2, are identical.  
```{r}
identical(df, df2)
```

## B  

```{r}
library(bio3d)
```
  
```{r, results='hide', fig.keep='none'}
s1 <- read.pdb("4AKE") # kinase with drug
s2 <- read.pdb("1AKE") # kinase no drug
s3 <- read.pdb("1E4Y") # kinase with drug
s1.chainA <- trim.pdb(s1, chain="A", elety="CA")
s2.chainA <- trim.pdb(s2, chain="A", elety="CA")
s3.chainA <- trim.pdb(s3, chain="A", elety="CA")
s1.b <- s1.chainA$atom$b
s2.b <- s2.chainA$atom$b
s3.b <- s3.chainA$atom$b
plotb3(s1.b, sse=s1.chainA, typ="l", ylab="Bfactor")
plotb3(s2.b, sse=s2.chainA, typ="l", ylab="Bfactor")
plotb3(s3.b, sse=s3.chainA, typ="l", ylab="Bfactor")
```

### Question 1:  
> What type of object is returned from the read.pdb() function?  
  
```{r}
s1 <- read.pdb("4AKE")
str(s1)
```

Returns a list.  

### Question 2:  
>What does the trim.pdb() function do?  
  
```{r}
help("trim.pdb")
```

It trims the original PDB object to contain a subset of the original atoms.  

### Question 3:  
>What input parameter would turn off the marginal black and grey rectangles in the plots and what do they represent in this case?  
  
```{r}
help("plotb3")
```

The *sse* parameter is what sets the marginal grey and black rectangles,
which represents the major secondary structure elements (SSEs) of the protein.  

### Question 4:  
>What would be a better plot to compare across the different proteins?
  
A scatterplot of RMSD data from aligned protein sequences.
Alignment would allow for significant residue-residue comparisons.  

### Question 5:  
>Which proteins are more similar to each other in their B-factor trends. How could you quantify this?  
  
Use hierarchical clustering with the calculated distances between protein structures to identify which are more similar.  

```{r}
hc <- hclust(dist(rbind(s1.b, s2.b, s3.b)))
plot(hc)
```
  
The kinases with drugs (4AKE and 1E4Y) are more similar to each other than to the kinase without drugs (1AKE).  

### Question 6:  
>How would you generalize the original code above to work with any set of input protein structures?  
  
The function below is used to construct plots for proteins of interest where
B-factor is plotted across the residues of the proteins, and secondary structure
is represented by boxes at the top and bottom of the figure. This function will print these plots while invisibly returning a NULL list.  

```{r}
# Argument          (type)              [Description]
# ==============================================================================
# protein_vector    character vector    PDB IDs for proteins of interest
# trim_chain        character vector    Identifiers for chains for trim.pdb
# trim_elety        character vector    Identifiers for atoms for trim.pdb
# plotb3_typ        character string    Identifier of plot type for plotb3
# plotb3_ylab       character string    Desired y-axis label of graph for plotb3
#===============================================================================

structure_analysis <- function(protein_vector,
                               trim_chain = "A", 
                               trim_elety = "CA", 
                               plotb3_typ = "l", 
                               plotb3_ylab = "Bfactor") {
  # Call sapply() in invisible() to suppress the visible 'NULL' output
  invisible(
    
    #Apply this function across the user-specified 'protein_vector'
    sapply(protein_vector, 
           
           # Plot a graph of the B-factor of a given residue in a protein
           function(protein = x){
             
             # Extract the trimmed structure of chain 'trim_chain' with atoms
             # 'trim_elety' using trim.pdb()
             structure.chainA <- trim.pdb(read.pdb(protein), 
                                          chain=trim_chain, 
                                          elety=trim_elety)
             
             # Plot the B-factor for each residue across the protein with
             # secondary structures of 'trim_chain' denoted by boxes on the 
             # bottom and top of the plot using plotb3()
             plotb3(structure.chainA$atom$b, 
                    sse=structure.chainA, 
                    typ=plotb3_typ, 
                    ylab=plotb3_ylab)
           }
    )
  )
}

# Call structure_analysis() on a vector where each component is a PDB ID of a 
# protein of interest
structure_analysis(c("4AKE", "1AKE", "1E4Y"))
```

